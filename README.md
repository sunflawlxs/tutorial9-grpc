# Tutorial 9 (gRPC)
Nama: Sheryl Ivana Widjaja<br>
NPM: 2206824943<br>
Kelas: Pemrograman Lanjut - A<br>

---
## REFLEKSI 1

###### 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

* RPC Unary: Jenis RPC paling dasar di mana klien mengirim satu permintaan ke server dan menerima satu respons sebagai balasan. Ini digunakan dalam situasi permintaan dan respons sederhana seperti autentikasi atau pengiriman formulir. 
* RPC Streaming Server: Klien mengirim satu permintaan ke server dan menerima respons dalam bentuk aliran yang terdiri dari beberapa pesan. Klien membaca pesan dari aliran tersebut hingga tidak ada lagi pesan yang dikirim ke server.
* RPC Bi-directional: Menggunakan stream yang dapat dibaca dan ditulis (read-write), klien dan server dapat mengirim serangkaian pesan. Kedua stream beroperasi secara independen, sehingga klien dan server dapat membaca dan menulis data dalam urutan yang berbeda. Ini ideal untuk aplikasi yang memerlukan pertukaran data besar antara klien dan server, seperti aplikasi obrolan.

###### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
* Autentikasi: Otentikasi komunikasi antara klien dan server menggunakan mekanisme otentikasi yang kuat seperti TLS (Transport Layer Security). Memanfaatkan mutual TLS (mTLS), di mana klien dan server mengautentikasi satu sama lain menggunakan sertifikat, memastikan bahwa kedua belah pihak adalah yang mereka klaim. Menerapkan protokol autentikasi seperti OAuth 2.0 atau JWT (JSON Web Tokens) untuk autentikasi pengguna, terutama jika klien perlu mengautentikasi dirinya sendiri.
* Autorisasi: Menetapkan dan menegakkan kebijakan kontrol akses berdasarkan kontrol akses berbasis peran (RBAC) atau kontrol akses berbasis atribut (ABAC). Aktifkan mekanisme untuk membatasi akses ke sumber daya berdasarkan identitas klien.
Pastikan keputusan otorisasi dibuat secara konsisten di seluruh titik akhir layanan dan otorisasi sisi server diterapkan untuk mencegah akses tidak sah.
* Enkripsi Data: Untuk mencegah akses yang tidak diinginkan, enkripsi data penting saat sedang transit dan saat disimpan. Untuk menjamin bahwa semua komunikasi antara klien dan server terlindungi, enkripsi data saat sedang transit menggunakan TLS. Gunakan teknik enkripsi yang kuat dan prosedur manajemen kunci untuk melindungi informasi yang disimpan di disk atau database. Sebelum menyimpan data dalam database, pertimbangkan untuk mengenkripsinya pada tingkat aplikasi, terutama jika data tersebut berisi data yang sangat sensitif.
* Menulis Kode Rust Aman: Untuk menulis kode Rust yang aman, patuhi praktik yang disarankan dan hindari kelemahan keamanan umum seperti injeksi SQL, buffer overflows, dan skrip lintas situs (XSS).
Manfaatkan perpustakaan dan kerangka kerja yang telah diaudit dengan baik dan memiliki catatan keamanan yang kuat.
Untuk menemukan dan memperbaiki kemungkinan kelemahan keamanan pada basis kode, lakukan audit keamanan rutin dan tinjauan kode.
* Secure Konfigurasi
Konfigurasikan server dan klien gRPC secara aman dengan menonaktifkan fungsi yang tidak digunakan, meminimalkan penggunaan protokol berisiko, dan menyiapkan enkripsi dengan tepat.
Hindari melakukan hardcoding pada elemen konfigurasi sensitif seperti kunci enkripsi atau token autentikasi dalam kode sumber atau file konfigurasi; sebaliknya, simpanlah dengan aman.

###### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Mengelola streaming dua arah di Rust gRPC menimbulkan kesulitan pada konkurensi, penanganan kesalahan, manajemen koneksi, dan kontrol aliran, terutama dalam situasi seperti aplikasi chat. Untuk menjamin konsistensi dan ketergantungan data saat mengelola komunikasi asinkron antara klien dan server, diperlukan sinkronisasi dan penanganan kesalahan yang tepat. Untuk menjaga kinerja dan stabilitas, masalah lain termasuk tekanan balik, pengurutan pesan, skalabilitas, dan kompleksitas pengujian harus diselesaikan. Menggunakan fitur pemrograman asinkron Rust, menerapkan metode penanganan kesalahan yang kuat, menyederhanakan manajemen koneksi, dan menggunakan teknik kontrol aliran untuk mengelola aliran pesan secara efisien semuanya diperlukan untuk solusi yang efektif. Untuk memastikan keandalan dan kinerja streaming dua arah di aplikasi Rust gRPC, pengujian dan debugging ekstensif diperlukan untuk menemukan dan memperbaiki kemungkinan masalah.

###### 4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
Menggunakan wrapper untuk tokio_stream::Manfaat interaksi yang lancar dengan runtime asinkron Tokio membuat ReceiverStream untuk streaming jawaban di layanan gRPC Rust sangat cocok untuk aplikasi yang saat ini menggunakan Tokio untuk I/O asinkron. Layanan Rust gRPC mampu menangani jawaban streaming dengan baik tanpa mengganggu loop peristiwa, berkat kemampuannya menangani streaming data asinkron dan fleksibilitas dalam mengelola berbagai jenis aliran. Namun, metode ini menambahkan ketergantungan pada Tokio, yang mungkin tidak sesuai untuk proyek yang menggunakan runtime asinkron lainnya. Selain itu, meskipun ReceiverStream berfungsi dengan baik dalam situasi streaming sederhana, ia mungkin tidak memiliki semua kemampuan canggih dan pilihan penyesuaian yang tersedia di perpustakaan streaming lainnya.

###### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
Layanan gRPC Rust harus dirancang dengan pemisahan masalah yang jelas dalam basis kode, dengan deskripsi dan implementasi layanan terpisah untuk memungkinkan pertukaran implementasi yang sederhana. Hal ini akan meningkatkan penggunaan kembali kode, modularitas, pemeliharaan, dan ekstensibilitas. Kemampuan pengujian dan fleksibilitas ditingkatkan dengan penggunaan objek sifat dan pola injeksi ketergantungan, yang memungkinkan penggabungan yang longgar antar komponen. Untuk membuatnya lebih mudah diakses dan digunakan kembali di seluruh perangkat lunak, elemen dan utilitas yang dapat digunakan kembali harus dimasukkan dalam modul atau peti independen. Selain itu, memastikan kemampuan beradaptasi terhadap perubahan persyaratan dan keadaan sambil menjaga ketahanan terhadap kegagalan dipastikan dengan membuat parameter perilaku layanan dan menciptakan prosedur penanganan kesalahan yang konsisten. Dengan mendorong basis kode yang dapat dikelola dan diperluas, metode ini memungkinkan pembuatan sistem gRPC Rust yang rumit dengan cepat dan efektif seiring waktu.

###### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Tahapan lebih lanjut diperlukan dalam implementasi MyPaymentService untuk mendukung logika pemrosesan pembayaran yang lebih kompleks. Hal ini termasuk menciptakan rangkaian pengujian yang komprehensif untuk memverifikasi kebenaran dan ketahanan sistem, membangun skalabilitas dan ketersediaan tinggi untuk mengakomodasi fluktuasi lalu lintas dan menjamin layanan tanpa gangguan, berintegrasi dengan gerbang pembayaran eksternal atau lembaga keuangan, mencatat dan menyimpan data transaksi untuk audit dan pencatatan. menerapkan pemrosesan konkurensi dan paralel untuk optimalisasi kinerja, mematuhi standar keamanan dan persyaratan kepatuhan, serta menetapkan mekanisme pemantauan dan peringatan untuk kesehatan sistem. Fase-fase ini memungkinkan logika pemrosesan pembayaran memenuhi persyaratan sistem pembayaran dunia nyata dan menangani skenario yang lebih rumit dengan efektif.

###### 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Dampak Adopsi gRPC pada Arsitektur dan Desain Sistem Terdistribusi: gRPC mengubah arsitektur dan desain sistem terdistribusi secara signifikan. gRPC menangani koneksi secara otomatis, sehingga klien tidak perlu memikirkan bagaimana mendapatkan akses modul melalui metode HTTP. Kesepakatan file proto antara klien dan server memungkinkan klien memanggil fungsi server seolah-olah mereka berinteraksi secara langsung. Ini menyederhanakan konektivitas dan operasi sistem.

###### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
Untuk REST API, penggunaan HTTP/2—protokol dasar gRPC—menawarkan sejumlah manfaat dibandingkan HTTP/1.1 atau HTTP/1.1 dengan WebSocket, seperti prioritas streaming, kompresi header, multiplexing, dan server push. Kombinasi faktor-faktor ini menghasilkan latensi yang lebih rendah, peningkatan efektivitas, dan penggunaan sumber daya jaringan yang lebih baik. Namun, dibandingkan dengan HTTP/1.1, HTTP/2 mungkin memerlukan lebih banyak sumber daya server, memberikan tantangan bagi sistem lama untuk bekerja, dan meningkatkan kompleksitas implementasi dan pemecahan masalah. Selain itu, WebSocket lebih sesuai untuk skenario komunikasi dupleks penuh waktu nyata meskipun HTTP/2 memungkinkan komunikasi dua arah. Saat memilih antara HTTP/2, HTTP/1.1, atau WebSocket, pengembang harus hati-hati mempertimbangkan trade-off antara beberapa aspek, termasuk kebutuhan kompatibilitas, persyaratan kinerja, dan kasus penggunaan API tertentu.
###### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
Karakteristik REST API: Dikenal karena kesederhanaannya, menggunakan metode HTTP standar dan tidak statis untuk kemudahan penggunaan. Tidak mendukung komunikasi real-time, sering menggunakan polling atau long-polling, yang dapat meningkatkan kompleksitas dan latensi. Karakteristik gRPC: Menawarkan streaming dua arah yang memungkinkan klien dan server untuk mengirim data secara independen.
Perbandingan antara gRPC dan REST API: REST API mudah digunakan, tetapi seringkali bergantung pada teknik polling atau longpolling dan tidak mendukung komunikasi real-time. gRPC, meskipun lebih sulit diimplementasikan, menawarkan kemampuan streaming dua arah yang dapat meningkatkan kinerja dan manfaat komunikasi real-time dalam beberapa penggunaan.

###### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
gRPC dengan Protocol Buffer: menawarkan kompatibilitas yang lebih baik, kinerja yang lebih baik, dan alat yang lebih baik karena menggunakan pendekatan berbasis skema. Ini cocok untuk situasi yang membutuhkan typing dan kinerja yang kuat. * JSON dalam REST API: menawarkan fleksibilitas dan keterbacaan di berbagai bahasa dan platform. Namun, dalam beberapa kasus, ini dapat menyebabkan biaya tambahan. * Pilihan antara keduanya: - Keput